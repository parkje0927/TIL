- CDN(Content Delivery Network) 에 대해 설명해주세요.
```
콘텐츠를 효율적으로 전달하기 위해 여러 노드를 가진 네트워크에 데이터를 저장하여 제공하는 시스템을 말한다. 
즉, 지리적으로 분산된 여러 개의 서버를 말하며, 웹 콘텐츠를 사용자와 가까운 곳에서 전송함으로써 전송 속도를 높인다. 전 세계 데이터센터는 파일 복사본을 임시로 저장하는 프로세스인 캐싱을 사용한다. 따라서 사용자는 가까운 서버를 통해 웹 활성화 디바이스 또는 브라우저에서 인터넷 콘텐츠에 빠르게 접속할 수 있다. CDN 은 웹 페이지, 이미지, 비디오 등의 콘텐츠를 사용자의 물리적 위치와 가까운 프록시 서버에 캐싱한다. 이렇게 하면 콘텐츠가 로딩될 때까지 기다릴 필요 없이 작업을 할 수 있다.
```

- 트래픽이 많아지면 어떻게 되는지, 어떻게 대처해야 하는지 설명해주세요.(예측되는 현상 및 해결 방향)
```
예상과 달리 많은 사람들이 들어와서 트래픽이 많아진다면 서버가 느려지고 나중에는 멈춰버리는 상황에 처할 수 있다. 이를 해결하는 방법은 크게 2가지가 있다. 

1. 현재 서버를 upgrade 하는 Scale-Up
더 좋은 CPU, 더 많은 RAM 등을 통해 단순히 서버의 처리 능력을 좋게 만들어 트래픽을 서버가 처리할 수 있도록 만드는 방법이다. 하지만 증가 대비 비용이 많이 비싸서 한계가 있다. 

2. 서버를 여러 개로 만드는 Scale-Out
Scale-Up 보다는 경제적이지만 메모리를 공유하지 않는다는 점에서 로그인 관련 세션 쿠키가 공유되지 못하거나 DB 데이터 불일치 등의 문제가 발생할 수 있다. 이런 문제를 데이터 정합성 문제라고 한다.

이를 해결하는 방법으로는 먼저, Sticky Session 즉 말 그대로 고정된 세션 방법이 있다. 각 웹 서버에 유저들을 전담시킨다고 보면 된다. A 가 1번 웹 서버에서 로그인을 하면 앞으로도 1번 웹 서버에서 담당하도록 Load Balancer 가 들어온 요청의 쿠키를 확인하고 해당하는 웹 서버에게 전달하는 방식이다. 이를 통해 정합성 문제는 해결할 수 있지만 특정 서버에 트래픽이 집중될 수 있는 단점을 가진다. 즉, 트래픽 분산이 잘 되지 않으며 한 서버가 예기치 않게 중단되었을 때 해당 세션이 날아가는 끔찍한 상황이 발생할 수 있다.

다른 방법으로는 Session Clustering 이 있다. 이는 여러 대의 컴퓨터가 하나의 시스템처럼 작동하도록 만드는 것을 말한다. 대표적으로 Tomcat 의 DeltaManager 를 사용한 all-to-all Session Replication 이 있다. 이는 모든 서버가 세션 저장소를 전부 똑같이 복제해서 가지고 있는 것을 말한다. 이 방법은 정합성 문제도 해결할 수 있으며, 한 서버가 예기치 않게 중단되었을 때에도 세션을 보존할 수 있게 된다. 하지만 많은 메모리가 필요하고 세션값이 추가 또는 변경될 때 마다 모든 서버값을 변경해야 하므로 서버 수에 비례하여 네트워크 트래픽이 증가하게 된다. 따라서 전반적인 성능 저하로 이어지기 때문에 적합하지 않다.

primary-secondary Session Replication
각 세션별로 primary 서버와 secondary 서버를 지정함으로써 메모리 문제를 해결하고자 했다. 
primary 서버 : 세선 저장
secondary 서버 : 세션 복제본 저장
나머지 서버 : JSESSION ID 만 저장

세션 스토리지 분리
세션 저장소를 각 서버에 두는 게 아니라 따로 분리하여 하나로 통합하는 방식이다. 따로 세션을 위한 데이터베이스를 만들어서 이를 참조하는 방식을 말한다. 여기서 디스크 기반의 데이터베이스는, 디스크에 저장을 해서 영구적으로 보관 가능하나 I/O 가 느린 단점이 있고, 인메모리 방식은 I/O 에 대한 부담이 적고 속도는 빠르지만 휘발성인 단점이 있다. 
```

- 세션이 무엇인지 설명하고, 서버가 여러 대일때 세션을 어떻게 처리하는지 설명해주세요.
```
세션은 클라이언트와 웹 서버 간 네트워크 연결이 지속 유지되고 있는 상태를 말한다. 즉, 사용자가 브라우저룰 열어 서버에 접속한 뒤 접속을 종료할 때까지의 시점을 말한다.

세션 클러스터링 : 여러 대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작하도록 만드는 것이 클러스터링인데, 서버 또한 여러 대가 하나의 서비스를 하기 위해서는 클러스터링이 필요하다. 세션을 공유하는 방법은 아래와 같다. 

1. All-to-all Session Replication
하나의 세션 저장소에 변경되는 요소가 발생하면 변경된 사항이 다른 모든 세션에 복제가 된다는 것을 말한다. 복제하면 유저가 이후에 어떤 서버에 접속하더라도 로그인 정보가 세션에 복제되어 있으므로 정합성 이슈가 해결 가능하다. 하지만 동일한 세션 객체를 가져야해서 많은 메모리가 필요하고, 데이터가 저장될 때마다 모든 서버에 값을 입력해야해서 서버 수에 비례하여 네트워크 트래픽이 증가하는 성능 저하가 발생한다.

2. BackupManager 를 활용한 primary-secondary 세션 복제 방식
primary 서버는 secondary(backup) 서버에 세션 객체의 key-value 전체를 복제한다. 하지만 이외의 서버에는 key 에 해당하는 JSESSION ID 만을 복제하기 때문에 all-to-all 방식보다 줄어들게 된다. 하지만 proxy 서버에 세션 정보를 요청할 경우에는 다시 primary 서버에 요청하여 해당 key 에 해당하는 객체를 받아와야 한다.

3. 세션 스토리지 분리를 통한 scale-out
이는 기존 서버가 갖고 있는 로컬 세션 저장소를 이용하는 것이 아니라, 별도의 세션 저장소를 사용하는 것을 의미한다. 세션 스토리지가 분리되면, 서버가 아무리 늘어난다고 할지라도 세션 스토리지에 대한 정보만 각각의 서버에 입력해주면 세션을 공유할 수 있게 된다. 또한 서버가 하나 장애가 발생해도 별도의 세션 저장소가 존재하기 때문에 가용성을 확보할 수 있다. 그리고 여러 대의 서버가 하나의 세션을 사용하기 때문에 데이터 정합성 문제도 해결된다. 

그러면 어떤 데이터베이스가 세션 스토리지에 적합할까?
1. 디스크 기반 데이터베이스
MySQL, Oracle, MS-SQL 등과 같은 관계형 데이터베이스가 있다. 디스크에 저장함으로써 전원이 공급되지 않더라도 저장이 가능하지만, In-Memory 방식보다는 속도가 현저히 느리다.

2. In-Memory 데이터베이스
메모리에 데이터를 저장하고 관리해서 I/O 에 대한 부담을 덜 수 있다. 하지만 전원 공급이 없을 경우 데이터를 전부 잃어버리게 된다.


그러면 In-Memory 에 세션을 저장하는 것이 좋을까?
만약 로그인한 사용자 정보와 같이, 일정 시간이 지나면 자동적으로 만료시키는 정보나 로그아웃 후 만료되는 세션 객체의 경우에는 영구적으로 저장하는 데이터가 아니며 현재 사용 중이지 않는 사용자 데이터까지 저장할 필요가 없으므로 In-Memory 를 세션 저장소로 사용하는 것이 좋다. 또한 In-Memory 데이터베이스의 장애로 인해 내부에서 소멸하더라도 사용자가 다시 로그인을 하게 되면 서비스 이용이 가능하다. 물론 이러한 서비스 중단을 해결하기 위해 Replication 기능을 통해 Master-Slave 구조로 이중화를 하게 된다. 만약 Master DB 에 장애가 발생할 경우, Slave DB 를 Master DB 로 승격시켜 서비스 중단 없이 지속적으로 제공할 수 있다.

세션저장소로 In-Memory 데이터베이스를 활용할 때 어떤 데이터베이스를 이용하면 좋을까?
데이터베이스를 선택하기 전에, 세션 객체가 어떤 형태인지 살펴봐야한다. 세션 객체는 key-value 형태로 구성되어 있어, 비교적 간단한 연산을 통해 처리될 수 있다. 세션 저장소로 많이 사용되는 것이 Redis, Memcached 이다. 
Redis 의 경우, Replication 을 지원하기 때문에 서버 하나에 장애가 발생해도 복제된 Slave 서버를 Master 로 승격시켜서 서비스 중단 없이 운영할 수 있다. 하지만 Memcached 의 경우 Replication 을 지원하지 않는다. 또한 Redis 는 대규모 트래픽 환경에서 Memcached 보다 응답 속도 안정성이 떨어질 수 있다. 마지막으로 Redis 는 싱글 스레드로 동작하고, Memcached 는 멀티 스레드로 동작을 하며 Redis 는 Read 연산에서 더 좋은 성능을 보여주고 Memcached 의 경우 Write 연산에서 더 좋은 성능을 보여준다.

* Redis, Memcached 차이점 조사

참고 : https://hyuntaeknote.tistory.com/8?category=867120
```

- 웹 애플리케이션 서버(Web Application Server) 동작방식에 대해서 설명해주세요.
```

```

- XSS에 대해 설명하고, XSS를 막기 위한 방법들에 대해 설명해주세요
```
XSS 공격은 웹 응용 프로그램에 존재하는 취약점을 기반으로 웹 서버와 클라이언트 간 통신 방식인 HTTP 프로토콜 동작과정 중에 발생한다.
사용자의 정보인 쿠키, 세션 등을 탈취하거나 주로 다른 웹 사이트와 정보를 교환하는 식으로 작동하므로 사이트 간 스크립팅이라고 한다.

- 저장 XSS 공격
웹 애플리케이션 취약점이 있는 웹 서버에 악성 스크립트를 영구적으로 저장해 놓는 방법

- 반사 XSS 공격
지정된 변수를 이용할 때 발생하는 취약점을 이용하는 것으로 서버가 외부에서 입력 받은 값을 받아 브라우저에게 응답할 때 전송하는 과정에서 변수의 위험한 문자를 사용자에게 그대로 돌려주면서 발생

- DOM 기반 공격
공격 스크립트가 DOM 생성의 일부로 실행되면서 공격

이를 해결하기 위해 입력값 제한을 하여 스크립트를 삽입하지 못하도록 해야한다.
또한 입력값 치환, 스크립트 영역에 출력 자제 등으로 막을 수 있다.
```