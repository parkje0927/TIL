- DB 락의 종류에 대해 설명해주세요.
```
Lock 은 하나의 트랜잭션이 완벽하게 끝날 때까지 다른 요청을 막아주며 트랜잭션 처리의 순차성을 보장해주는 기능을 제공한다. 
종류로는 Shared Lock, Exclusive Lock 이 있다. 

Shared Lock
Read Lock 이라고 불리며 데이터를 읽을 때 사용되어지는 Lock 이다. 이런 공유 Lock 끼리는 동시에 접근이 가능하다. 즉 하나의 데이터를 읽는 것은 여러 사용자가 동시에 할 수 있다라는 것이다. 하지만 공유 Lock 이 설정된 데이터에 베타 Lock 을 사용할 수 없다.

Exclusive Lock
베타 Lock 은 데이터를 변경하고자 할 때 사용되며, 트랜잭션이 완료될 때까지 유지된다. 베타락은 Lock 이 해제될 때까지 다른 트랜잭션은 해당 리소스에 접근할 수 없다. 또한 해당 Lock 은 다른 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함께 Lock 을 설정할 수 없다.

---
글로벌 락
`flush tables with read lock;`
→ read O, write X

테이블 락
- read lock : read 할 거니까 update 하지마
`lock tables ‘테이블명’ read;`

- write lock : update 할 거니까 read 하지마
`lock tables ‘테이블명’ write;`

네임드 락
`select get_lock(’디비명’, 30)` ⇒ 이거가 Lock 을 가져감. 그러면 다른 곳에서 read 하려할 때 안된다.
→ `select release_lock(’디비명’)` ⇒ lock 풀어준다.
```

- 데이터베이스 튜닝의 3가지 단계에 대해 설명해주세요.
```
데이터베이스 설계 튜닝, 데이터베이스 환경 튜닝, SQL 문장 튜닝 3가지가 존재한다.
설계 튜닝은 데이터베이스 설계단계에서 성능을 고려하는 것이고, 환경 튜닝은 성능을 고려하여 메모리나 블록 크기 등을 지정하는 것을 의미한다. SQL 문장 튜닝은 성능을 고려하여 SQL 작성하고 쿼리 문장을 수정하는 것이다.
```

- 인덱스(Index)에 대해 설명해주세요
```
인덱스는 데이터베이스에서 table 의 검색 성능을 높여주는 방법 중 하나이다. 인덱스는 책 목차와 같은 역할을 하는 자료구조로 데이터를 검색할 때 인덱스를 통해 훨씬 빠른 속도로 검색할 수 있다.
특정 컬럼에 대해 인덱스를 해놓으면 search-key 가 정렬되어 저장되기 때문에 조건 검색 속도가 굉장히 빠르다. 하지만 그만큼 추가 저장공간이 필요하게 되고 인덱스를 많이 추가할 경우 속도가 느려질 수 있어서 인덱스 사용을 통해 검색 성능향상이 더 큰 경우에만 생성하는 것이 좋다.
```

- 인덱스(Index)를 사용할 때 주의할 점에 대해 설명해주세요
```
인덱스는 select where 절에 대해서만 성능 향상을 해준다. 이외에 데이터를 수정하게 되면 모든 인덱스를 업데이트 해야하기 때문에 오히려 성능 저하를 초래한다. 또한 index 를 생성할때마다 저장공간도 차지하기 때문에 무분별하게 생성하면 안된다.
자주 조회되고, 수정 빈도가 낮으며 카디널리티는 높고 선택도가 낮은 컬럼을 선택해야한다.
```

- 인덱스(Index)의 구현에 사용되는 대표적인 자료구조에 대해 설명해주세요
```
b+tree 구조가 있다. hash table 을 사용하면 검색 시간이 O(1) 로 b+tree 보다는 빠르지만 값이 정렬되어 있지 않아서 매우 비효율적이기 때문에 b+tree 를 사용한다.
b+tree 구조는 항상 정렬된 상태를 유지하여 부등호 연산에 유리하며 조회, 저장, 수정, 삭제시에 항상 O(logN) 시간 복잡도를 갖는다.
```

- 데이터베이스 정규화에 대해 설명해주세요
```
정규화의 목적은 중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 방지하는 것이고 각 relation 에 중복된 종속성을 여러 개의 relation 에 분할하는 것이다. 또한 어떠한 relation 이라도 데이터베이스 내에서 표현 가능하게 하는 것이 있다.
정규화 과정은 총 6개가 있다. 1NF 는 도메인이 원자값이어야 한다. 2NF 를 만족하려면 부분적 함수 종속을 제거해야 하고 3NF 를 만족하려면 이행적 함수 종속을 제거해야 한다. BCNF 는 결정자이면서 후보키가 아닌 것을 제거해야 한다. 4NF 를 만족하려면 다치 종속성을 제거해야 하고, 5NF 는 조인 종속성을 제거해야 한다.
```

- 데이터베이스 힌트에 대해 설명해주세요
```
SQL 튜닝의 핵심 부분, 지시구문이다.
오라클이 항상 최적의 실행 경로를 만들 수 없기에 직접 최적의 실행 경로를 작성해주는 것이다. 힌트를 사용하면 액세스 경로, 병렬 및 직렬 처리, 옵티마이저 목표 변경이 가능하다.
```

- 이상 현상의 종류에 대해 설명해주세요
```
이상현상이란 데이터 삽입, 수정 등에서 발생할 수 있는 부작용으로 불필요한 데이터 중복 문제를 말한다.
1) 삽입 이상
데이터를 삽입하기 위해 불필요한 데이터도 같이 삽입해야 하는 문제
2) 삭제 이상
튜플 삭제 시 꼭 필요한 데이터도 같이 삭제되는 문제
3) 갱신 이상
중복 튜플 중 일부만 업데이트하여 데이터 불일치가 발생하는 문제

이런 문제를 해결하기 위해 정규화 과정이 필요하다. 정규화란, 이상 현상을 제거하기 위해 DB 를 올바르게 설계해나가는 과정이다.
```

- 데이터베이스 클러스터링과 리플리케이션의 차이에 대해 설명해주세요
```
클러스터링은 동일한 데이터베이스를 여러 대의 서버가 관리하도록 구축하는 것을 의미한다.
방법으로는 Active-Active, Active-StandBy 방식이 있다.
Active-Active 방식은 모든 데이터베이스가 활성 상태이기 때문에 한 서버에 문제가 생겨도 다른 서버를 이용할 수 있다는 장점이 있다. 하지만 모든 서버가 활성 상태여서 병목 현상이 생길 수 있다.
반면 Active-StandBy 형식은, 한 서버는 Active, 다른 서버는 StandBy 상태로 놔두고 Active 서버에 문제가 있을 경우 StandBy 서버가 Active 상태로 전환되는 방법을 의미한다. 이 경우 앞서 발생한 병목 현상을 해결할 수 있지만 전환하는 동안 서비스가 중단되는 문제가 발생한다.

반면, 리플리케이션이란 복제를 의미하는 것으로 원본을 Master, 복제를 Slave 라고 부른다. 이 두 데이터베이스는 서로 다른 명령어를 수행할 수 있는데, Master 에서는 crud 에서 create, update, delete 만 수행이 되고 select 조회 작업은 Slave 에서 처리한다.
이렇게 할 경우 부하를 분산시킬 수 있으며, 데이터가 복제가 되어 있기 때문에 Slave 데이터를 통해 복구할 수 있다는 장점이 있다. 하지만 Slave 데이터베이스가 비동기 방식으로 Master 데이터베이스를 동기화하기 때문에 일관성에 문제가 생기며 Master 데이터베이스에 문제가 생길 경우 이 동기화에서도 문제가 생겨서 단점이 생긴다.
```