- OOP 에 대해 설명해주세요.
```
객체지향프로그래밍, 즉 객체의 관점에서 프로그래밍을 한다는 의미이다. 
먼저 캡슐화란, 하나의 객체에 대해 그 객체가 특정한 목적을 위한 필요한 변수나 메소드를 하나로 묶는 것을 의미한다. 
정보은닉은, getter, setter 등의 메소드를 통해서만 간접적으로 접근이 가능하도록 한다. 
추상화는 목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념을 의미하며, 다형성은 형태가 같은데 다른 기능을 하는 것을 의미한다. (ex : overriding, overloading)
마지막으로 상속은 재사용을 높여서 코드의 중복을 없애고 효율성을 높인다. 
```

- DDD(Domain-Driven-Design)에서 Domain이란 무엇인가요?
```
먼저, DDD 란 도메인 패턴을 중심에 놓고 설계하는 방식을 일컫는다. 일반적으로 많이 사용하는 데이터 중심의 접근법을 탈피해서 순수한 도메인의 모델과 로직에 집중하는 것을 말한다. 여기서 도메인이란, 사용자가 사용하는 모든 것이며 실세계에서 사건이 발생하는 집합이다. 즉, 유사한 업무의 집합으로 어플리케이션을 비즈니스 도메인 별로 나누어 설계하라는 의미이다. 도메인은 사용자에 따라 또는 사용자가 바라보는 관점에 따라 지속적으로 변하므로 문맥에 따라 객체의 역할이 바뀌는 특징이 있다. DDD 의 목적은 소프트웨어의 복잡성을 최소화하는 것에 있다. 
```

- 단위 테스트를 작성할 때 Mock을 하는 이유는 무엇일까요? 기능이 정상 동작 하려면 외부 모듈 또는 객체에 의존해야 하는데 왜 이 의존성을 끊으려고 할까요?
```
Mock 이란, 개발자가 동작을 직접 제어할 수 있는 가짜 객체를 지원하는 테스트 프레임워크이다. 실제 객체를 만들어서 테스트하기에는 시간, 비용이 높거나 객체 서로 간의 의존성이 강해 구현하기 힘들 경우 가짜 객체를 만들어 사용하는 방법이다. 즉, 테스트 작성 환경 구축이 어렵거나 다른 것에 의존적일 경우, 테스트 시간이 오래 걸리는 경우 Mock 을 활용한다.
기능이 정상 동작 하려면 외부 모듈 또는 객체에 의존해야 하지만 단위 테스트는 한 번에 메서드 하나만을 실행해는 보는 것인데도 이 메서드가 다른 네트워크, 데이터베이스 등 제어하기 어려운 것에 의존하고 있다면 테스트 수행이 어려워진다. 따라서 이 의존성을 끊기 위해 Mock 을 활용한다.
```

- 빌더 패턴에 대해 설명하고 빌더 패턴이 어떻게 구현되는지 설명해주세요.
```
빌더 패턴이란 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴이다.
빌더 패턴의 장점은 다음과 같다.
1) 필요한 데이터만 설정할 수 있다. 
생성자나 수정자를 통해서 데이터를 설정하게 될 경우, 만약 어떤 필드가 필요 없는 상황이라면 이 필드에 더미값을 넣어서 생성하거나 이 필드가 없는 생성자를 또 하나 만들어야 한다. 하지만 빌더를 통해서 생성하게 되면 필요한 데이터만 가지고 설정을 할 수 있다. 

2) 유연성을 확보할 수 있다. 
객체에 새로운 필드가 추가될 경우, 기존 생성자에는 해당 필드를 모두 넣어서 수정해줘야하지만 빌더 패턴을 이용하게 되면 기존 코드를 수정할 필요가 없다. 1)번과 같은 이유로 수정하지 않고 유연하게 값을 설정할 수 있다. 

3) 가독성을 높일 수 있다.
생성자의 경우 어떤 필드에 값을 설정하는지 한 눈에 확인하기가 어렵지만, 빌더는 어떤 필드에 값을 설정하는지 한 번에 확인할 수 있다.

4) 변경 가능성을 최소화할 수 있다. 
setter 는 불필요하게 변경 가능성을 열어두는 것이다. 값을 어디서 할당하는지를 찾는 것이 어려우므로 유지보수하기가 어렵지만, 만약 값 할당 시점을 객체 생성 시점으로 제한한다면 유지보수가 더 편리해진다.

하지만, 만약 라이브러리를 통해 객체를 생성을 하거나 객체의 필드가 2개 이하라면 빌더 패턴을 구현할 필요가 없다.

빌더 패턴 구현 방법은 아래와 같다. 
먼저 public static 클래스로 생성한다. 그리고 생성자는 public 으로 하며, 필수값에 대해서는 생성자를 통해, 선택값들에 대해서는 메소드를 통해 구현한다.
선택값들에 대해서는 각각의 속성마다 메소드로 제공하며 반환은 빌더 객체 자신이다.

public class Test {
	
	public static class TestBuilder {
		private String required1;
		private String required2;

		private String optional1;
		private String optional2;

		public TestBuilder(String required1, String required2) {
			this.required1 = required1;
			this.required2 = required2;
		}

		public TestBuilder setOptional1(String optional1) {
			this.optional1 = optional1;
			return this;
		}

		public TestBuilder setOptional2(String optional2) {
			this.optional2 = optional2;
			return this;
		}

		public Test build() {
			return new Test(this);
		}
	}
}
```

- 메모리 구조에 대해 설명해주세요.
```
프로그램이 운영체제로부터 할당 받는 대표적인 메모리 공간은, '코드 영역, 데이터 영역, 스택 영역, 힙 영역' 이렇게 총 4개로 구성된다.

- 코드 영역
실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고도 불린다.
CPU 는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리한다.
가장 낮은 주소에 위치한다.
(상수, 함수가 저장된다.)

- 데이터 영역
프로그램의 전역 변수와 정적 변수가 저장되는 영역이며 프로그램의 시작과 함께 할당되며 프로그램 종료시 소멸된다.
(전역변수, 정적변수가 저장된다.)

- 힙 영역 FIFO
사용자가 직접 관리할 수 있는 그리고 해야만 하는 메모리 영역이다.
사용자에 의해 메모리 공간이 동적으로 할당되고 해제되며, 낮은 주소에서 높은 주소 방향으로 할당된다.
(동적할당이 되는 변수들이 저장된다.)

- 스택 영역 LIFO
함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다.
스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸된다. 
높은 주소에서 낮은 주소의 방향으로 할당된다.
(지역변수가 저장된다.)

참고 : http://www.tcpschool.com/c/c_memory_structure
```

- DDD(Domain-Driven-Design)에서 얘기하는 3가지 계층과 각각의 역할에 대해 설명해 주세요.
```
DDD는 해당 도메인과 일치하도록 소프트웨어를 모델링하는 소프트웨어 설계 접근 방식이다. DDD 에서 이야기하는 3가지 계층은, 도메인 모델 계층, 애플리케이션 계층, 인프라 계층이 있다. 
먼저 도메인 모델 계층은 비즈니스 소프트웨어의 핵심으로 비즈니스 상황을 반영한 상태가 여기서 제어되고 사용된다. 비즈니스 개념/상황 정보/규칙을 나타내는 작업을 담당하는 역할을 한다. 
애플리케이션 계층은 소프트웨어가 수행할 작업을 정의하고 도메인 개체가 문제를 해결하도록 지시하는 역할을 한다. 
마지막으로 인프라 계층은 최초에 도메인 엔티티에 있던 데이터가 데이터베이스나 기타 영구 저장소에 유지되는 방식이다.
```

- 싱글톤 패턴에 대해 설명하고 언제 사용할 수 있는지 예를 들어주세요.
```
```

- 쿠키는 클라이언트 어느부분에 저장되나요?
```
쿠키 전달 과정은 서버가 클라이언트 요청에 응답할 때 일어난다. Set-Cookie 라는 응답헤더에 쿠키 정보를 명시하도록 되어 있고 서버로부터 쿠키 응답을 받은 브라우저는 해당 쿠키를 클라이언트 컴퓨터 하드 디스크에 저장한다. 그리고 동일한 서버에 요청을 할 때 해당 쿠키를 Cookie 라는 요청 헤더에 실어서 보낸다.
이때 쿠키의 유효기간이 명시되지 않은 쿠키를 세션 쿠키라고 부르는데 브라우저의 세선이 종료될 때 만료가 된다. 반면에 유효기간이 명시되어 있는 쿠키인 영속 쿠키는 특정 기간이나 특정 시점까지 유효하다.
```

- TDD(Test-Driven-Devlopement)가 무엇이며 중요 개념이 무엇인가요?
```
테스트 주도 개발. 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스 중 하나이다.
중요 개념은 결정과 피드백 사이의 갭을 조절하기 위한 기술이다. 어떤 방법으로 구현을 할지에 대한 결정과 그 결정의 결과인 피드백 사이의 갭이 커질수록 문제가 된다. 하지만 TDD 를 통해 불확실성을 줄이고 피드백이 증가하여 협력을 증진시키게 된다.
```

- 사전에서 검색을 제공하는 Application을 구현하고자 할 때 어떤 자료구조를 사용해 구현하실 건가요? 이유와 함께 설명해주세요
```
사전에서 한 단어에 여러 개의 뜻을 가지고 있을 수 있기 때문에 Map<String, List<>> 구조로 구현할 것 같습니다. key 가 검색어이며 그 검색 결과를 List 로 받아와서 보여주도록 설계할 것 같습니다.
```

- MSA에 대해 설명하고 MSA가 갖는 장점과 단점에 대해 설명해주세요
```
MSA 란 마이크로 서비스 아키텍처(Micro Service Architecture)의 약자로 단일 프로그램을 각 컴포넌트 별로 나누어 작은 서비스의 조합으로 구축하는 방법이다.
장점은, 각각 개별의 서비스 개발을 빠르게 하고 유지보수도 쉽다. 그리고 회사 팀 단위로 기술 스택을 다르게 설정할 수 있다. 그리고 서비스별로 독립적 배포가 가능하며 개별적 scale-out 이 가능하다.
단점은, 상대적으로 복잡하다는 것이 단점이다. 서비스가 모두 분산되어 있으며 통합 테스트도 어렵고 따라서 실제 운영환경에 배포하는 것도 쉽지 않다.
```

- CORS(Cross-Origin-Resource-Sharing)에 대해 설명해주세요
```
브라우저가 리소스 로드를 허용해야 하는 모든 출처를 서버가 표시할 수 있도록 한다.
url 구조는 https://google.com/qwer?page=1 라는 url 이 있을 때, 

https:// => protocol
google.com => host
qwer => path
page=1 => query string 

로 구분할 수 있다.
여기서 origin 출처란, protocol, host, port 를 합친 것을 말한다. 여기서 3개 중에 하나만 달라도 다른 출처로 인식이 되고, 브라우저가 동일 출철 정책(SOP)를 지키기 위해 다른 출처의 리소스 접근을 막기 위해 CORS Policy 오류가 나타나게 된다.
CORS 동작 원리는 단순 요청 방법과 예비 요청을 먼저 보내는 방법 2가지가 있다.

단순 요청 방법은 서버에 바로 요청을 보내는 방법이며 아래 조건을 만족해야 한다.
- 요청 메소드는 GET, HEAD, POST 중 하나여야 한다.
- Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width 를 제외한 헤더를 사용하면 안 된다.
- Content-Type 헤더는 application/x-www-form-urlencoded, multipart/form-data, text/plain 중 하나를 사용해야 한다.

예비 요청을 먼저 보내는 방법은 preflight 요청이다. 예비 요청을 보내서 안전한지 판단한 후 본 요청을 보내는 방법이다. 실제 리소스를 요청하기 전에 OPTIONS 라는 메소드를 통해 실제 요청을 전송할지 판단한다.

CORS 오류를 해결하기 위해서는 서버에서 몇가지 응답 헤더를 포함하는 설정을 추가해야한다.
```

- 함수형 프로그래밍에 대해 설명해주세요
```
함수형 프로그래밍은 자료 처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리한느 프로그래밍 패러다임의 하나이다. 함수는 코드 구성의 기본이며 모든 고차원 프로그래밍 언어에 존재한다. 일반적으로 함수형 프로그래밍은 깨끗하고 유지보수가 쉬운 소프트웨어를 만들기 위해 함수를 최상의 효과로 사용하는 것을 의미한다.

- 변경 가능한 상태를 불변 상태로 만들어 side effect 를 없애자
- 모든 것은 객체이다.
- 코드를 간결하게 하고 가독성을 높여 구현할 로직에 집중하자
- 동시성 작업을 쉽고 안전하게 구현하자
```

- 동적 프로그래밍(Dynamic Programming)에 대해 설명해주세요
```
큰 문를 작은 문로 나눠서 푸는 문제를 말한다. 모든 방법을 일일이 검토하여 최적의 해를 찾아내는 방식으로 결과적으로 효율적인 값을 택한다. 그런 면에서 시간이 오래 걸리지만 결과적으로는 항상 최적의 해를 구할수 있다는 장점이 있다.
```

- 동적 프로그래밍(Dynamic Programming)이 갖는 2가지 조건은 무엇인가요?
```
2가지 조건은 부분 반복 문제와 최적 부분 구조이다.
부분 반복 문제 : 계속해서 같은 부분 문제가 여러번 재사용되거나 재귀 알고리즘을 통해 해결되는 문제
최적 부분 구조 : 작은 부분 문제에서 구한 최적의 답으로 합쳐진 큰 문제의 최적 답을 구할 수 있어야 한다.
```

- HTTP 메서드와 각각이 사용되는 경우에 대해서 설명해주세요.
```
- GET : 데이터를 받아올 때 사용한다.
- HEAD : GET 요청와 동일한 응답을 요구하지만 응답 본문을 포함하지 않는다.
- POST : 특정 리소스에 데이터를 제출할 때 쓴다. 서버의 상태 변화나, DB 에 값을 저장할 때 사용한다.
- PUT : 내용 갱신 위주이다. POST 처럼 정보를 서버로 제출하지만 갱신 위주일 때 사용한다.
- DELETE : 삭제 시에 사용한다.
- CONNECT : 프록시 서버와 같은 중간 서버를 경유할 때 사용한다.
- OPTIONS : 가능한 메소드 옵션에 대한 질의를 할 때 사용한다.
- TRACE : 요청 리소스가 수신되는 경로를 보여준다.
- PATCH : 리소스의 일부분을 수정한다.
```

- CSRF에 대해 설명하고, 이를 막기 위한 방법들에 대해 설명해주세요
```
CSRF(Cross-Site Request Forgery)는 악성 웹사이트 공격유형이다. 웹 사이트가 신뢰하는 사용자로부터 권한 없는 요청을 전송한다. 사용자가 원하지 않는 HTTP 요청을 전송하게 되고 -> 그러면 공격자가 어떤 링크를 따라가게 만들어서 사용자가 자신도 모르게 로그아웃이 되거나 하는 공격을 당하게 되는 것이다.

이를 막기 위한 방법으로는 비밀 토큰 유효성 검증, 리퍼러 유효성 검증, 요청되지 않은 인증 요청 거부 방법이 있다. 먼저 비밀 토큰 유효성 검증은 시크릿 토큰을 사용하여 인증의 유효성을 검증하는 것이고, 리퍼러 유효성 검증은 referer 헤더의 유효성을 검증하도록 구성하는 것을 의미한다. 마지막으로 요청되지 않은 인증 요청 거부는 요청하지 않은 로그인 요청과 같은 것을 거부하도록 구성하는 것을 의미한다.
```

- Docker와 Kubernates에 대해 설명해주세요
```
도커는 컨테이너 기반의 오픈소스 가상화 플랫폼이다. 컨테이너란 애플리케이션과 애플리케이션을 구동하는 환경을 호스트 os 로부터 격리한 공간을 의미한다. 
쿠버네티스란 컨테이너 오케스트레이션 툴이다. 컨테이너도 수가 많아지면 운영에 있어서 어려움이 있는데 이런 다수의 컨테이너 실행을 관리 및 조율하는 시스템이다. 쿠버네티스는 복구 자동화, 로드 밸런싱, 무중단 서비스, 호환성의 장점을 가지고 있다.
```

- 허프만 코딩에 대해 설명해주세요
```
입력 파일의 문자 빈도 수를 가지고 최소힙을 이용하여 파일을 압축하는 과정이다.
빈도 수를 계산해서 -> 빈도 수를 우선순위로 최소힙을 구성 -> 빈도 수가 가장 작은 두 노드들을 삭제 -> 삭제한 두 노드 중에 작은 것을 왼쪽 자식 노드, 큰 것을 오른쪽 자식 노드로 삽입 -> 노드가 하나 남을 때까지 반복 -> 마지막 노드가 루트 노드가 된다.
```

- Elastic Search에 대해서 간단히 설명해주세요
```
아파치 루씬 기반의 Java 기반 오픈 소스 분산 검색 엔진이다. 방대한 양의 데이터를 신속하게 저장, 검색, 분석할 수 있으며 단독으로 사용되기도 하고 Logstash, Kibana 와 같이 ELK 스택으로 사용되기도 한다.
ElasticSearch 는 샤드를 통해 규모가 수평적으로 확장되고, Replica 를 통해 안전성이 보장된다. 그리고 스키마 개념이 없다는 것이 특징이다.
```

- Restful API 의 장점
```
Restful 이란, 일반적으로 REST 라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어로, REST 를 REST 답게 쓰기 위한 방법이다. 목적은 이해하기 쉽고 사용하기 쉬운 Rest API 를 만드는 것이고, API 의 이해도 및 호환성을 높이는 것이 주동기이다.

REST API 설계 규칙
- URI 는 정보의 자원을 표현해야한다. 동사보다는 명사를, 대문자보다는 소문자를 사용해야한다.
- 자원에 대한 행위는 get, put, post, delete 으로 표현해야한다.
```

- BCrypt 암호화 방식에 대해 설명해주세요
```
패스워드 암호화 알고리즘으로 암호 단방향 해싱 함수이다. 해싱을 할 때 내부적으로 랜덤한 salt 를 생성하기 때문에 같은 문자열에 대해서 매번 다른 해싱 결과를 도출한다.
그리고 해시값 내부에 salt 값이 포함되기 때문에 salt 값을 따로 저장하지 않아도 해싱된 값과 평문을 비교할 수 있다.
```

- 알고있는 Http Response들에 대해 얘기해주세요
```
1xx : 요청을 받고 프로세스를 계속 진행
2xx : 요청 성공
3xx : 리다이렉션
4xx : 클라이언트 오류
5xx : 서버 오류

주로 사용하는 것은 다음과 같다.
200 : ok
201 : Created, 요청이 성공했고 새로운 리소스가 생성되었다.
204 : No-Content
400 : Bad Request
401 : Unauthorized
403 : Forbidden
500 : Internal Server Error
```

- TDD(Test-Driven-Devlopement)의 장점과 단점에 대해 설명해주세요
```
장점은, 높은 퀄리티의 소프트웨어를 보장한다는 것이다. 그렇게 된다면 유지보수에 용이할 것이고, 추가적인 요구사항이 있을 때 손쉽게 반영할 수 있을 것이다. 하지만 단점으로는 개발 기간이 정해져있기 때문에 테스트 코드 작성으로 인해 생산성이 저하될 수 있다. 테스트 원칙 때문에 쉽게 넘어가지 못하는 상황도 발생할 수 있다.
```

- 파사드 패턴에 대해 설명하고 언제 사용할 수 있는지 예를 들어주세요
```
일련의 저수준 인터페이스들을 하나의 고수준 인터페이스로 묶어주는 패턴이다. 클라이언트 객체가 여러 저수준 인터페이스의 동작을 제어하려면 여러 저수준 인터페이스를 모두 호출해야하는데 파사드 패턴을 이용하면 고수준 인터페이스 하나만 호출해도 가능해진다. 내부의 복잡한 동작을 모두 감싸서 외부에는 간단한 동작만 공개하면 되며, 모듈간의 결합도를 낮추고 연결성과 종속성을 낮춘다. 그렇기 때문에 하나의 인터페이스만 클라이언트에 제공해야할 때 사용한다.

사용자 입장에서는 서브 클래스들에 대해 알 필요가 없으며, 공통적인 목표는 서브 시스템들 사이의 의사소통 및 종속성을 최소화하여 이런 목표를 달성하도록 도와주는 패턴이다.
```

- Byte Ordering에 대해 설명해주세요(추가 공부 필요)
```
Byte Ordering 은 데이터를 메모리 번지에 저장하는 순서를 의미한다. 
1) Big-endian
낮은 주소에 값이 높은 자리가 저장된다.

2) Little-endian
높은 주소에 값이 낮은 자리가 저장된다.
```

- OOP의 5가지 설계 원칙들에 대해 설명해주세요
```
1) 단일 책임의 원칙 SRP
하나의 모듈이 하나의 책임을 가져야 한다.

2) 개방 폐쇄 원칙 OCP
확장에 대해 열려있고 수정에 대해 닫혀있어야 한다.

3) 인터페이스 분리 원칙 ISP
목적과 용도에 적합한 인터페이스만을 제공하는 것이다.

4) 리스코프 치환의 원칙 LSP
하위 타입은 상위 타입을 대체할 수 있어야 한다.

5) 의존 역전 원칙
고수준 모듈(입력과 출력으로부터 먼 추상화 모듈) 은 저수준 모듈(입력과 출력으로부터 가까운 구현 모듈)의 구현에 의존해서는 안 되며, 저수준 모듈이 고수준 모듈에 의존해야 한다.
```

- 가교 패턴
```
구현 코드로부터 추상을 분리하여 독립적으로 발전할 수 있도록 하기 위한 목적을 가지는 패턴, 상속은 구현과 추상을 결속시키지만 가굑 패턴을 사용하여 추상과 구현을 분리하여 문제를 해결할 수 있다.
```

- 복합체 패턴
```
객체들의 관계를 트리 구조로 구성하여 전체-부분 계층을 표현하는 패턴
```

- 팩토리 메서드 패턴에 대해 설명하고 언제 사용할 수 있는지 예를 들어주세요
```
생성 패턴 중 하나로 객체를 생성할 때 어떤 클래스의 인스턴스로 만들지 서브 클래스에서 결정하게 된다.
기존 코드의 변경 없어도 되며, 수정에는 닫혀있고 확장에는 열려있는 원칙을 지킬 수 있다.
```

- 데코레이터 페턴
```
객체에 동적으로 새로운 책임을 추가할 수 있게 한다. 기능을 추가를 위해 상속을 이용하는 것보다 유용한 방법은, 지금 필요한 테두리를 추가하는 다른 객체에대가 해당 구성 요소를 둘러싸는 것이다. 이렇게 무엇인가를 감사는 객체를 장식자라고 한다.
즉, 장식자는 자신이 둘러싼 구성 요소로 전달되는 요청을 중간에 가로채서 해당 구성요소에 전달해준다.
```

- Serverless에 대해 설명해주세요
```
개발자가 서버를 관리할 필요 없이 애플리케이션을 빌드하고 실행할 수 있도록 하는 클라우드 네이티브 개발 모델이다.

- BaaS(Backend as a Service)
Firebase 와 같은 BaaS 를 활용하면 데이터베이스, 파일 시스템 등을 API 로 제공해줌으로써 서버 개발을 하지 않고서도 필요한 기능을 개발할 수 있다.

- FaaS(Function as a Service)
프로젝트를 여러 개의 함수로 쪼개서 이 함수들이 실행되는 횟수만큼 비용을 내는 방식을 말한다.
```

- 메세지 큐에 대해 설명하고, 알고 있는 메세지 큐를 얘기해주세요
```
메세지 큐는 서로 다른 프로그램 사이에 공유할 수 있는 무제한 크기의 버퍼이다.
프로세스 또는 프로그램 인스턴스가 데이터를 서로 교환할 때 사용하는 통신 방법이며 메시지 지향 미들웨어를 구현한 시스템이다. 메시지 지향 미들웨어 MOM 이란 비동기 메시지를 사용하는 응용 프로그램 간의 데이터 송수신을 말한다.

AMQP 를 이용하여 메시지를 교환하고 이는 ISO 응용 계층 프로토콜의 표준이다.
알고 있는 메세지 큐는 RabbitMQ 가 있다.
RabbitMQ 는 producers 에서 consumers 로 메세지를 전달할 때 브로커 역할을 한다.
중요 개념으로는 먼저 producer 는 요청을 보내는 주체이고, 메세지를 exchange 에 publish 한다. consumer 는 메세지를 받아 처리하는 주체이고, exchange 는 producer 로부터 전달 받은 메세지를 어떤 queue 로 보낼지 결정하는 장소이다. queue 는 보관하는 장소이고 binding 은 특정 exchange 가 특정 queue 를 binding 하도록 정의한다.
```

- Elasticsearch의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요
```
RDBMS 의 like 검색을 할 경우, 만약 1억건 이상의 데이터 안에서 %키워드% 검색을 할 경우, 1억개의 데이터 모두를 조회해야하므로 속도나 안정성에서 이슈가 발생할 수 있다.
반면 Elasticsearch 의 역인덱스 방식은 조금 다르다. 텍스트를 여러개의 키워드로 쪼개는데 이 키워드는 자기 자신이 등장한 document 를 가리킨다. 따라서 앞의 예제와 같이 1억개의 데이터를 탐색할 필요 없이 해당 키워드가 가리키는 document 가 무엇인지 확인하면 된다. 그러면 마치 HashTable 을 사용하는 것처럼 시간 복잡도가 거의 O(1) 에 수렴한다.
```

- 세션 기반의 인증과 토큰 기반의 인증의 차이에 대해 얘개해주세요
- 쿠키와 세션에 대해서 설명하고 사용하는 이유에 대해 얘기해주세요