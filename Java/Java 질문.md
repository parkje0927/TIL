1. Java 에서 제공하는 List, Set, Map 에 대해 설명해주세요.
```
[순서가 있는 목록 List]
List 인터페이스의 가장 큰 차이점은 배열처럼 "순서"가 있다는 것이다. ArrayList 와 Vector 클래스의 사용법은 거의 동일하고 기능도 거의 비슷한 "확장 가능한 배열"이다. 하지만 ArrayList 는 thread safe 하지 않고, Vector 는 thread safe 하다. 
ArrayList 는 객체를 선언할 때 매개 변수를 넣지 않으면 초기 크기는 10이다. 따라서 10개 이상의 데이터가 들어가면 크기를 늘이는 작업이 ArrayList 내부에서 자동으로 수행된다. 참고로 자바의 모든 객체가 생성되면 그 객체가 위치하는 주소가 내부적으로 할당된다.

[순서가 중요하지 않은 Set]
순서에 상관 없이, 어떤 데이터가 존재하는지를 확인하기 위한 용도로 많이 사용된다. 다시 말해서 중복되는 것을 방지하고, 원하는 값이 포함되어 있는지를 확인하는 것이 주 용도이다. 
- HashSet : 순서가 전혀 필요 없는 데이터를 저장한다. Set 중에 가장 성능이 좋다. 
- TreeSet : 저장된 데이터의 값에 따라서 정렬되는 셋이다. red-black 이라는 트리 타입으로 값이 저장되며, HashSet 보다 약간 성능이 느리다.
- LinkedHashSet : 연결된 목록 타입으로 구현된 해시 테이블에 데이터를 저장한다. 저장된 순서에 따라 값이 정렬된다. 성능이 셋 중에 가장 나쁘다. 

[key-value 형태로 저장되는 Map]
모든 데이터는 키와 값이 존재한다.
키가 없이 값만 저장될 수 없다. 
값 없이 키만 저장할 수도 없다. 
키는 해당 Map 에서 고유해야만 한다. 
값은 Map 에서 중복되어도 전혀 상관 없다.
```

- 불변 객체가 무엇인지 설명하고 대표적인 Java 의 예시를 설명해주세요. 그리고 왜 객체를 불변으로 만들어야 하는지, 어떠한 장점이 있는지 설명해주세요.
```
불변객체는 재할당은 가능하지만, 한 번 할당하면 내부 데이터를 변경할 수 없는 객체를 의미한다. 즉 객체에 값을 할당하면 내부 데이터를 변경시킬 수 없다는 것이다. 대표적인 예로는 String, Integer, Boolean 등이 있다.

장점은
- 객체에 대한 신뢰도가 높아진다. 
- 생성자, 접근 메소드에 대한 방어 복사가 필요 없다.
- 멀티스레드 환경에서 동기화 처리 없이 객체를 공유할 수 있다.

단점은
- 객체가 가지는 값마다 새로운 객체가 필요하다. 따라서 메모리 누수와 새로운 객체를 계속 생성해야하기 때문에 성능 저하를 발생시킬 수 있다.
```

- Immutable Object 만들기
    - final 을 사용하면 setter 를 구현할 수 없으므로 value 를 변경하려면 재할당하는 방법밖에 없다.
    - 하지만 불변 객체라면 그 참조 변수 또한 불변이어야 한다.
```java
public class Test {
    private final int value;

    public Test(final int value) {
        this.value = value;
    }
}
```


```java
public class Test {
    private final Age age;

    public Test(final Age age) {
        this.age = age;
    }

    //getter
}

class Age {
    private final int value;

    public Age(final int value) {
        this.value = value;
    }

    //getter
}
```

```java
public class Test {
    private final List<Animal> animals;

    public Test(final List<Animal> animals) {
        this.animals = new ArrayList<>(animals);
    }

    public List<Animal> getAnimals() {
        return Collections.unmodifiedList(animals);
    }
}
```

- Java 언어를 만든 사람이 누군인지 아시나요?
```
썬 마이크로시스템즈에서 1995년에 개발한 객체 지향 프로그래밍 언어로 창시자는 제임스 고슬링이다. 2010년에 오라클이 썬 마이크로시스템즈를 인수하면서 Java 의 저작권을 고휴하였다. 
```

- JVM 구조에 대해 설명해주세요.
```
자바 가상 머신으로 자바 바이트 코드를 실행할 수 있는 주체이다. 즉 자바 코드를 컴파일해서 얻은 바이트 코드를 해당 운영체제가 이해할 수 있는 기계어로 바꿔 실행시켜주는 역할을 한다. 
JVM 의 구성을 살펴보면 크게 4가지(Class Loader, Execution Engine, Garbage Collector, Runtime Data Area)로 나뉜다.

Class Loader
자바 소스를 자바 컴파일러가 컴파일하면 클래스 파일(바이트 코드)이 생성된다. 이렇게 생성된 클래스 파일들을 엮어서 JVM 이 운영체제로부터 할당 받은 메모리 영역인 Runtime Data Area 로 적재하는 역할을 Class Loader 가 한다.

Execution Engine
Class Loader 에 의해 메모리에 적재된 클래스들을 기계어로 변경해 명령어 단위로 실행하는 역할을 한다.

Garbage Collector
Heap 메모리 영역에 생성된 객체들 중에 참조되지 않는 객체들을 탐색 후 제거하는 역할을 한다.

Runtime Data Area
JVM 의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다. 이 영역은 크게 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack 으로 나눌 수 있다.
```

- Java 의 String 과 StringBuilder 의 차이에 대해 설명하고 언제 StringBuilder 를 사용하면 좋을지 얘기해주세요.
```
String 과 StringBuffer/StringBuilder 클래스의 가장 큰 차이점은 String 은 불변의 속성을 갖는다.

만약, 
String str = "hello";
str += "world";

라는 코드가 있다면, 기존에 "hello" 값이 들어가있던 String 클래스의 참조변수 str 이 "hello world" 라는 값을 가지고 있는 새로운 메모리 영역을 가리키게 변경되고 처음 "hello"로 값이 할당되어 있던 메모리 영역은 GC 에 의해 사라진다.
변하지 않는 문자열을 자주 읽어들이는 경우 String 을 사용하면 좋으나 추가, 수정, 삭제 연산이 빈번하게 발생하는 경우에는 heap 메모리에 임시 가비지가 많이 생성되어 힙메모리 부족으로 이어질 수 있다.

반면, StringBuffer/StringBuilder 는 둘 다 가변성을 가지는 클래스로 동일 객체 내에서 문자열 변경이 가능하여 문자열 추가, 수정, 삭제가 빈번할 경우 String 보다 이 클래스들을 활용해야 한다. 
또한 이 둘의 차이는, StringBuffer 는 동기화를 지원해 멀티쓰레드 환경에서 안전하지만, StringBuilder 는 동기화를 지원하지 않아서 멀티 스레드 환경에서는 적합하지 않지만 동기화를 고려하지 않는 만큼 단일 스레드에서는 성능이 뛰어나다.
```

- 접근제어자의 종류와 특성에 대해 설명해주세요.
```
1) private
private 이 붙은 변수, 메소드는 해당 클래스에서만 접근이 가능하다.
2) default
접근 제어자를 별도로 설정하지 않으면 접근 제어자가 없는 변수, 메소드는 default 접근 제어자가 되어 해당 패키지 내에서만 접근이 가능하다.
3) protected
protected 가 붙은 변수, 메소드는 동일 패키지의 클래스 또는 해당 클래스를 상속받은 다른 패키지의 클래스에서만 접근 가능하다.
4) public
어떤 클래스에서라도 접근이 가능하다.
```

- 템플릿 메소드 패턴이란 무엇인가요?
```
어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴이다. 전체적으로 동일하면서 부분적으로는 다른 구문으로 구성된 메소드의 코드 중복을 최소화할때 유용하다.
```

- final 키워드에 대해 설명해주세요
```
final 을 붙이면 시간이 지나도 처음 정의된 상태가 변하지 않는 것을 보장한다.
final variable, arguments : 값이 변경되지 않도록 만든다.
final class : 클래스를 상속하지 못하도록 만든다.
fianl method : 메소드가 오버라이드되지 못하도록 만든다.
```

- try-with-resources에 대해 설명해주세요
```
이전에는 try-catch-finally 로 처리를 했는데 JDK7부터 추가된 개념이다.
try 에 자원 객체를 전달하고 try 코드 블록이 끝나면 finally 블록 없이도 자동으로 자원을 종료해주는 기능이다. 
사용 방법은 try(...) 안에 객체 선언 및 할당을 해주면 try 문을 벗어나면 try(...) 안에서 선언된 객체의 close() 메소드들을 호출한다. 그래서 finally 에 close() 를 명시적으로 호출해줄 필요 없이 자동으로 종료가 되는 것이다.
여기서 close() 를 호출해주는 객체는 AutoCloseable 을 구현한 객체만 호출이 되므로 내가 만든 클래스가 자원해제되길 원한다면 해당 인터페이스를 implements 해야 한다.
```

- 추상클래스에 있는 protected 메소드를 오버라이딩하여 구현하려고 한다. 각각 private, protected, public으로 구현할 때 이 중 불가능한 것은 무엇이고 왜 그렇게 생각했는지 설명해주세요
```
private 이다. 
먼저 public 의 경우에는 어떤 클래스라도 접근 가능하며 protected 의 경우에는 상속 관계에 있을 때 상속 받은 클래스에서 사용가능한 접근 제어자이다. 하지만 private 은 해당 클래스에서만 접근 가능하기 때문에 불가능하다.
```

- Java에서 제공하는 원시 타입들에 무엇이 있고, 각각 몇 바이트를 차지하나요?
```
- 논리형 boolean : 1byte
- 문자형 char : 2byte
- 정수형 byte : 1byte
- 정수형 short : 2byte
- 정수형 int : 4byte
- 정수형 long : 8byte
- 실수형 float : 4byte
- 실수형 double : 8byte
```

- 스택 2개로 큐를 구현해보세요
```
Stack1, Stack2 가 있고 Queue 를 구현한다고 했을 때, 예시로 1, 2, 3, 4 숫자를 Stack1 에 넣는다고 가정한다. 만약 Stack 구조에 넣고 pop 을 한다면 1, 2, 3, 4 로 넣은 데이터가 4, 3, 2, 1 순서로 조회가 될 것이다.
이때 Stack1 에 넣은 데이터를 하나씩 빼오면서 Stack2 에 넣는다. 그 이후에 Stack2 에서 데이터를 조회해오면 Queue 에 데이터를 넣고 조회해오는 것과 동일한 결과를 얻을 수 있다.
```

- 스트링 문자열을 거꾸로 만들어 반환하는 코드를 구현해보세요
```java
String str = "HELLO";

String reverseStr = "";
for (int i = str.length() - 1; i >= 0; i--) {
    reverseStr += str.charAt(i);
}

System.out.println(reverseStr);
```

```java
String str = "HELLO";

StringBuffer sb = new StringBuffer(str);
String reverseStr = sb.reverse().toString();

System.out.println(reverseStr);
```

- Java의 해시 맵(Hash Map)과 해시 테이블(Hash Table)의 차이에 대해 설명해주세요
```
두 자료구조 모두 Map 자료구조라는 점에서는 동일하지만 HashMap 은 동기화를 지원하지 않아서 단일스레드에서 사용하기 좋은 자료구조라는 장점이 있다. 반면 HashTable 은 동기화를 지원하며 thread-safe 하다.
```

- JVM, JRE, JDK에 대해 설명해주세요
```
JVM 은 자바 가상 머신을 의미한다. 어느 기기/운영체제에서나 실행될 수 있게 만들어주고 메모리를 효율적으로 관리를 해서 최적화를 해준다.
JRE 는 자바 런타임 환경을 의미한다. 자바 클래스 라이브러리, JVM, 자바 클래스 로더를 포함하고 있다. 
JDK 는 우리가 일반적으로 설치하는 자바 파일을 의미한다. JDK 를 설치하면 JRE, JVM 이 자동으로 다 설치된다. JDK 에는 자바 컴파일러를 포함하고 있다. .java 파일을 만들어서 실행하면 .class 라는 파일이 자동으로 생성된다.
```

- Java의 동작 과정과 Java의 장점과 단점에 대해 설명해주세요
```
```

- Java8이 이전 버전과 다른 점(추가된 기능)에 대해 설명해주세요
```
Java8 에 추가된 기능으로는 람다 표현식, Functional 인터페이스, Stream, Optional 등이 있다.
람다 표현식은 화살표 함수를 통해서 표현을 만들 수 있고, 익명 클래스로 전환이 가능하다. 
Optional 은 null 처리를 보다 간편하게 하기 위해서 만들어졌다. 
Stream 은 순차적으로 데이터를 처리하며 뭔가 연속된 정보를 처리하는데 사용한다. 예를 들어 컬렉션을 처리하면서 for 문을 수행하게 하거나 조건으로 거를 때 사용할 수 있다.
```

- 컬렉션 관련 메소드 알고있는 것들 설명해주세요
```
max() : 가장 큰 요소 반환
min() : 가장 작은 요소 반환
sort() : 오름차순 정렬
binarySearch() : 해당 값의 인덱스 반환
copy() : 새로운 컬렉션으로 복사해서 반환
reverse() : 순서 역으로 변경
emptyList() : 불변의 List 반환
```

- Static 키워드에 대해 설명해주세요
```
경우에 따라서 각 인스턴스들이 공통적으로 같은 값이 유지되어야 하는 경우 static 을 붙인다. 멤버 변수에 static 을 붙이게 되면 클래스가 메모리에 올라갈 때 그 변수가 자동적으로 생성되기 때문에 static 이 붙은 멤버 변수는 인스턴스를 생성하지 않아도 사용할 수 있다. 그리고 static 이 붙은 메소드는 인스턴스 생성 없이 호출가능한 반면 인스턴스 변수는 생성해야만 존재할 수 있어서 static 이 붙은 메서드에서는 인스턴스 변수의 사용을 허용하지 않는다.
그러므로 메소드에서 인스턴스 변수를 사용하지 않는 메소드에 대해서 static 을 붙일 것을 고려해야한다.
```

- Java의 Optional API에 대해 설명해주세요
```
T 타입의 객체를 포장해주는 래퍼 클래스이다. 따라서 Optional 인스턴스는 모든 타입의 참조 변수를 저장할 수 있다. 즉 Null 또는 값을 감싸서 NPE 로부터 부담을 줄이기 위해 Wrapper 클래스라고 볼 수 있다.
```

- Java에서 람다식 표현을 어떻게 쓰나요? 사용해본 경험이 있나요
```
람다 표현식은 반복문을 쓸 때 주로 사용을 했는데, for 문 보다 성능이 떨어질 수 있기 때문에 단순 반복문은 for 문을 사용한다.
사용시, 매개변수 화살표 함수 몸체로 이용하여 사용할 수 있다. 단일 실행문이면 괄호를 생략할 수 있으며 return 문으로만 구성되어 있으면 생략할 수 있다.
```

```java
list.stream().forEach(data -> {
    //로직
});

list.stream().forEach(data -> System.out.println(data.toString()));
```

- 쓰레드를 구현하기 위한 인터페이스, 클래스는 무엇이 있나요?
```
Runnable 인터페이스, Thread 클래스가 있다.
Runnable 인터페이스는 run() 메소드 한 개를 가지고 있어서 이를 구현하도록 되어 있는데 스레드가 시작될 때 run() 메소드가 실행되어 실행될 코드를 구현하는 것이다.
Thread 클래스는 컴퓨팅 시스템의 스레드 기능을 가진 클래스로, Runnable 인터페이스를 상속받고 있기에 run() 메소드만 구현해주면 된다.

Thread 방법이 간단해보이지만 다중 상속을 허용하지 않으므로 Thread 를 상속받으면 다른 클래스를 상속 받을 수 없다. 하지만 Runnable 인터페이스를 구현할 경우, 다른 클래스도 상속 받을 수 있다.
```

- Java의 Vector와 ArrayList의 차이에 대해 설명해주세요
```
Vector, ArrayList 모두 List 인터페이스를 상속 받고, 같은 동작을 수행하는 클래스이다.
하지만 먼저 동기화에서 차이가 있다.
Vector 는 단일 스레드만 접근 가능하기에 thread-safe 하고, ArrayList 는 멀티 스레드 환경에서 접근 가능하며 동기화 되지 않기에 동기화가 필요하다.
또한 Vector 는 자동으로 크기 증가시 현재 배열의 크기를 100% 증가시키지만, ArrayList 는 50% 증가시킨다.
```

- 데코레이터 패턴에 대해 설명하고 언제 사용할 수 있는지 예를 들어주세요
```
GoF 디자인 패턴 책 참고
개별적인 객체에 새로운 책임을 추가하려고 할 때, 해당 구성 요소를 둘러싸는 방법을 장식자라고 한다.
즉, 장식자는 자신이 둘러싼 구성 요소로 전달되는 요청을 중간에 가로채서 해당 구성 요소에 전달해준다.
- 다른 객체에 영향을 주지 않고 객객의 객체에 새로운 책임을 추가하기 위해 사용
- 제거될 수 있는 책임에 대해 사용
- 실제로 상속으로 서브 클래스를 만드는 것은 실질적이지 못할 때 사용한다. 너무 많은 수의 독립된 확장이 가능할 때 모든 조합을 지원하기 위해 이를 상속으로 해결하면 클래스 수가 폭발적으로 많아지게 된다. 

장점은,
단순한 상속보다 설계의 융통성을 더 많이 증대시킬 수 있다. 여러 서브 클래스를 포함하면 여러 책임을 조합하는 결과가 된다. 또한 책임 추가 작업에서 필요한 비용만 그때 지불하는 방법을 제공한다. 나중에 실제 그 기능이 필요할 때 새로운 종류의 데코레이터를 개발함으로써 가능하다.

하지만,
작은 규모의 객체들이 많이 생기게 된다. 객체들을 잘 이해하고 있다면 재정의가 쉽지만 그렇지 않다면 객체들을 모두 이해하고 수정하는 과정이 복잡해진다.

예시로는
스트림은 객체를 일련의 바이트나 문자로 변형시키는 인터페이스를 제공한다. 스트림 객체를 파일에 객체로 저장하거나 메모리에 스트링으로 저장할 수 있다.
또 다른 예시로는 @Component 어노테이션이 있다. => Spring 내용 좀 더 찾아볼 예정
```

- Java의 Stream API에 대해 설명해주세요
```
람다식, 함수형 인터페이스 등을 지원하면서 java 를 이용해 함수형으로 프로그래밍을 할 수 있는 API 를 제공해주고 있다.

- 원본의 데이터를 변경하지 않는다.
- 일회용이다.
- 내부 반복으로 작업을 처리한다.
```

- Call By Value와 Call By Reference의 차이에 대해 설명해주세요
```
- call by value : 값에 의한 호출
복사하여 처리를 하는데 그렇기 때문에 원래의 값이 보존이 된다. 하지만 복사를 해서 만들어서 메모리 사용량이 늘어나게 된다.

- call by reference : 참조에 의한 호출 
복사를 하지 않고 직접 참조를 하는 방식으로 원래 값이 영향을 받는다.
```

- 가비지 컬렉터에 대해 설명하고, 가비지 컬렉션 과정에 대해 설명해주세요
- 가비지 컬렉션 알고리즘의 종류에 대해 설명해주세요
- 싱글톤 클래스를 직접 구현해보세요
- 병렬 처리 프레임워크의 종류와 특징에 대해 설명해주세요
- 가비지 컬렉션에 의한 시스템 중단 시간을 줄이는 방법으로 무엇이 있을까요?
- C언어의 포인터에 대해 설명해주세요
- 메모리가 무엇인지 설명해주세요
- 메소드 오버라이딩과 오버로딩에 대해 설명해주세요
- 절차지향 프로그래밍과 객체지향 프로그래밍과 그 차이에 대해 설명해주세요
- 체크 예외와 언체크 예외에 대해 설명해주세요
- 컬렉션 중에 자신있게 설명할 수 있는 것을 설명해주세요
- 추상클래스와 인터페이스의 차이에 대해 설명해주세요