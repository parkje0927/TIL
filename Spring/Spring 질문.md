- JPA 영속성 컨텍스트의 이점(5가지)을 설명해주세요.
```
1. 1차 캐시
우선 1차 캐시에서 식별자 값(@Id)로 엔티티를 찾고, 찾는 엔티티가 있으면 데이터베이스를 조회하지 않고 메모리에 있는 1차 캐시에서 조회를 하기에 성능상 이점이 있다. 또한 만약 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성하고 그 엔티티를 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다.

2. 동일성 보장
영속성 컨텍스트(1차 캐시)에서 관리되는 엔티티를 가져왔을 경우 동일성을 보장한다.

3. 트랜잭션을 지원하는 쓰기 지연
트랜잭션 커밋 전까지 SQL 을 쓰기 지연 SQL 저장소에 보관한다. 그리고 커밋하는 순간 영속성 컨텍스트 내 쓰기 지연 SQL 저장소에 보관된 SQL 을 보낸다.

4. 변경 감지(Dirty Checking)
영속성 컨텍스트에서 관리하는 엔티티에 변경이 일어났을 경우 이를 감지하기 때문에 em.update(엔티티) 이런 코드가 필요 없다. 엔티티 변경이 일어난 후, flush()가 발생하면 엔티티와 스냅샷을 비교하고 -> UPDATE SQL 을 생성하여 쓰기 지연 저장소에 저장한 뒤 -> 쌓여있는 쓰기 지연 SQL 저장소의 SQL 을 DB 에 반영한다. 

5. 지연로딩
엔티티에서 해당 엔티티를 불러올 때 SQL 을 날려 해당 데이터를 가져온다.
```

- Spring Filter 와 Interceptor 의 차이에 대해 설명하고, 사용 예시를 설명해주세요.
```
요청이 들어오면 Filter -> Interceptor -> AOP -> Interceptor -> Filter 순으로 거치게 된다. 
1. 서버를 실행시켜 서블릿이 올라오는 동안에 init 이 실행되고, 그 후 doFilter 가 실행된다.
2. 컨트롤러에 들어가기 전 preHandler 가 실행된다.
3. 컨트롤러에서 나와 postHanlder, after Completion, doFilter 순으로 진행이 된다.
4. 서블릿 종료 시 destroy 가 실행된다.

Filter
요청과 응답을 거른 뒤 정제하는 역할을 한다. 서블릿 필터는 DispatcherServlet 이전에 실행이 되는데 필터가 동작하도록 지정된 자원의 앞단에서 요청 내용을 변경하거나 여러가지 체크를 수행할 수 있다.
스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작한다. 

- 예시
    - 공통된 보안 및 인증/인가 관련 작업
    - 모든 요청에 대한 로깅 또는 감사
    - 이미지/데이터 압축 및 문자열 인코딩
    - Spring 과 분리되어야 하는 기능

Interceptor
요청에 대한 작업 전/후로 가로챈다는 의미이다. 
스프링의 DispatcherServlet 이 컨트롤러를 호출하기 전/후로 끼어들기 때문에 스프링 컨텍스트 내부에서 Controller 에 관한 요청과 응답에 대해 처리한다. 

- 예시
    - 세부적인 보안 및 인증/인가 공통 작업
    - API 호출에 대한 로깅 또는 감사
    - Controller 로 넘겨주는 정보(데이터)의 가공
```

- 빈 주입 방법들과 가장 좋은 방법이 무엇인지, 왜 그것이 가장 좋은지 설명해주세요.
```
1. 생성자 주입
생성자 호출 시점에 1회 호출이 보장되어 주입받은 객체가 변하지 않거나 반드시 객체의 주입이 필요한 경우 강제하기 위해 사용할 수 있다. 

@Service
public class UserService {
    private UserRepository repository;

    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}

2. setter 주입
주입받는 객체가 변경될 가능성이 있는 경우 사용한다.

@Service
public class UserService {
    private UserRepository repository;

    @Autowired
    public void setUserRepository(UserRepository repository) {
        this.repository = repository;
    }
}

3. 필드 주입
필드에 바로 의존 관계를 주입하는 방법이다. 하지만 외부에서 변경이 불가능하다는 단점이 있어서 테스트 코드에서 이에 대한 제약이 존재한다.

@Service
public class UserService {

    @Autowired
    private UserRepository repository;
}

생성자 주입을 권장하고 있는데 이유는 다음과 같다.
- 생성자 주입을 통해 변경 가능성을 배제하고 불변성을 보장할 수 있다.
- 컴파일 시점에 객체를 주입받아 테스트 코드를 작성할 수 있으며, 주입하는 객체가 누락된 경우 오류를 발견할 수 있다.
- 생성자 주입을 사용하면 필드 객체에 final 키워드를 사용할 수 있으며, @RequiredArgsContructor 를 같이 활용하여 생성자 주입을 할 수 있다.
- 애플리케이션 구동 시점에 순환 참조 에러를 방지할 수 있다.
```

- Spring 컨테이너를 통한 싱글톤 패턴과 Java 를 이용해 구현하는 싱글톤 패턴의 차이에 대해 설명해주세요.
```
자바 싱글톤은 클래스로더에 의해 구현되고, 스프링의 싱글톤은 스프링 컨테이너에 의해 구현된다. 즉, 스프링 컨테이너를 통한 싱글톤 패턴은, 클래스 자체에 의해서가 아니라 스프링 컨테이너에 의해 구현된다. 특정 클래스에 @Bean 이 정의되면, 스프링 컨테이너는 그 클래스에 대해 딱 한 개의 인스턴스를 만든다.
자바 싱글톤의 scope 는 코드 전체이고, 스프링 싱글톤의 scope 는 해당 컨테이너 내부이다.
자바 싱글톤 패턴은 개발자의 로직에 따라 thread safety 를 보장할수도 있고, 보장하지 않을 수도 있다. 반면 스프링에 의해 구현되는 싱글톤 패턴은 Thread Safety 를 자동으로 보장한다. 

아래와 같이 작성된 경우, SingletonService 객체를 생성하기 위해 new SingletonService() 로 호출시 에러가 뜨게 된다.

public class SingletonService {
	private static final SingletonService instance = new SingletonService();

	public static SingletonService getInstance() {
		return instance;
	}

	private SingletonService() {

	}

	public void test() {
		System.out.prinln("싱글톤 객체 로직 호출");
	}
}

참고 : https://gem1n1.tistory.com/96
```

- Spring 프레임워크는 트래잭션을 어떻게 구현하였는지 설명해주세요.
```
트랜잭션은 스프링 AOP Proxy 를 통해 처리가 된다.
프록시 객체를 통해 기능 수행한 뒤 이상이 없으면 commit 을 하고 이상이 있으면 rollback 을 하게 된다.
Spring 에서는 @Transactional 어노테이션을 명시하게 되면 내부적으로 AOP 를 통해 트랜잭션 처리 코드가 전후로 수행된다.

여기서 AOP 는 관점 지향 프로그래밍으로, 포인트컷을 통해 특정 시점에 어떤 행위를 할 수 있도록 설계하는 방식을 말한다. AOP 는 일반적으로 2가지 방법이 있는데, JDK Dynamic Proxy 방식과 CGLIB 방식이 있다. 

- JDK Dynamic Proxy
트랜잭션 처리를 다이나믹 프록시 객체에 대신 위임하는 방식으로, 다이나믹 프록시 객체는 타깃이 상속하고 있는 인터페이스를 상속 후 추상 추상메소드를 구현하며, 내부적으로 타깃 메소드 호출 전후로 트랜잭션 처리를 수행한다.
이런 프록시 객체를 런타임 시점에 동적으로 만들어주기 때문에 다이나믹 프록시라고 한다.

- CGLIB
바이트 코드 생성 프레임워크를 사용하여 런타임 시점에 프록시 객체를 만드는 방식이다.

스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 한다.
트랜잭션 AOP 가 트랜잭션을 시작할 때 -> 영속성 컨텍스트가 생기고, 메소드가 종료되어 트랜잭션 AOP 가 트랜잭션을 커밋할 경우 -> 영속성 컨텍스트가 flush 되면서 해당 내용이 반영된다. -> 이후 영속성 컨텍스트 역시 종료

참고 : https://hwannny.tistory.com/98
```

- JPA에서 PK는 어떻게 설정하나요?
```
@Id 만 사용하는 경우와 @Id, @GeneratedValue 를 같이 사용하는 방법이 있으며 후자의 경우 4가지의 자동 생성 전략이 있다.
- IDENTITY
기본 키 생성을 데이터베이스에 위임, id 값을 null 로 하면 DB 가 알아서 AUTO_INCREMENT 해준다.
- SEQUENCE
Sequence Object 를 사용한다. 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트이다.
- TABLE
키 생성 전용 테이블을 만들어서 시퀀스처럼 이용하는 전략
- AUTO
데이터베이스 방언에 따라 3가지 전략을 자동으로 지정한다.
```

- Spring의 DI가 어떻게 동작하는지 설명해주세요.
```

```

- Spring의 3가지 Layer에 대해 설명해주세요
```
presentation layer, service layer, data access layer 3가지 계층과 모든 계층에서 사용되는 도메인 모델 클래스로 구성되어 있다. 각각의 계층은 독립적으로 분리하여 구현하는 것이 가능해야 하는데 presentation layer 는 요청 및 응답을 처리한다. 즉 비즈니스 로직과 최종 UI 를 분리하기 위해서 컨트롤러 기능을 제공한다.
service layer 는 비즈니스 로직 처리와 도메인 모델의 적합성 검증을 한다. data access layer 는 데이터 액세스 로직을 객체화하고 마지막으로 도메인 모델 클래스는 VO 또는 DTO 객체에 해당한다.
```

- Spring과 SpringBoot의 차이에 대해 설명해주세요
```
spring boot starter 가 대부분의 dependency 를 관리해준다.
spring boot 는 xml 설정을 하지 않아도 된다.
spring boot 는 AutoConfiguration 이 있어서 많은 외부 라이브러리, 내장 톰캣 서버등이 실행될 수 있다.
```

- API가 무엇인지 설명해주세요
```
API 는 Application Programming Interface 로 응용 프로그램에서 사용할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 의미한다.
```

- JPA FetchType에 대해 설명하고 각각 어떤 기준으로 사용하시는지 설명해주세요
```
- FetchType.LAZY 지연로딩
회원과 팀이라는 객체가 있을 때 지연로딩을 사용하게 되면 회원 엔티티를 조회할 때 팀 회원을 같이 조회하는 것이 아니라 실제로 팀 엔티티를 사용할 때 조회해오는 방법을 의미한다. 여기서 사용하는 방버은 프록시 전략이다. 실제 팀 엔티티를 가져오는 것이 아니라 프록시 객체가 들어가 있다가 실제로 사용할 때 이 프록시가 팀 엔티티 관련 데이터를 리턴 해준다.

- FetchType.EAGER 즉시로딩
즉시 연관된 엔티티도 다 조회해온다. 조인을 이용해 하나의 쿼리로 데이터를 가져오기 때문에 만약 특정 상황에서 데이터를 가져오지 못하는 상황이 발생한다면 null 이 될 수 있다.
```

- 프레임워크와 라이브러리의 차이점
```
프레임워크와 라이브러리의 차이점은 제어 흐름의 권한이 어디에 있는가이다.
라이브러리를 사용할 때 사용자는 애플리케이션 코드의 흐름을 직접 제어해야 한다. 
반면 프레임워크는 애플리케이션의 코드가 프레임워크에 의해 사용된다. 제어의 흐름은 프레임워크가 가지고 있고 사용자가 그 안에 필요한 코드를 작성하게 된다. 

라이브러리의 경우 애플리케이션의 흐름을 사용자가 직접 제어해야 하지만 프레임워크의 경우 코드를 연결할 수 있는 위치를 제공하고 사용자가 연결한 코드를 호출하는 제어 흐름 권한을 가지고 있다.
```

- Aop에서 Aspect, Advice, Pointcut 및 Joinpoint에 대해 설명해주세요
```
AOP 의 핵심 기능은 코드를 수정하지 않으면서 공통 기능의 구현을 추가하는 것이다. 즉, 핵심적인 관점, 부가적인 관점으로 나눠서 각각 모듈화하겠다는 의미이다. 
Aspect : Aspect 안에 모듈화 시킨 것
Advice : 실질적으로 어떤 일을 해야하는지를 담고 있다.
Pointcut : 어디에 적용해야하는지
Join Point : Advice 가 적용될 위치, 끼어들 수 있는 지점
```

- Lombok 라이브러리에 대해 알고 있나요? 알고 있다면 롬복이 만드는 메소드들이 생성되는 시점은 언제인가요?
```
Lombok 은 소스코드를 컴파일 하는 과정에 개입해서 추가적인 코드를 만든다. 이를 어노테이션 프로세싱이라고 하는데 더 자세히 살펴보면 다음과 같다.
1. javac 는 소스파일을 파싱하며 AST 트리를 만든다.
2. 롬복은 어노테이션 프로세서에 따라 AST 트리를 동적으로 수정하고 새 노드를 추가하고 마지막으로 바이트 코드를 분석 및 생성한다.
3. 마지막으로 javac 는 롬복 어노테이션 프로세서에 의해 수정된 AST 를 기반으로 바이트 코드를 생성한다.
```

- 사용자 등록/조회/수정/삭제에 대한 Rest API를 설계해보세요
```
사용자 정보를 저장할 때 Member 라는 도메인이 있고 index 가 pk 라고 하면, 등록은 spring data jpa 의 save() 기능을 활용하여 저장을 할 것이다. 그리고 수정을 할 때는 save() 기능이 insertOrUpdate 로 처리를 하기 때문에 같은 등록과 같은 메소드에서 수행하게 할 것이다.
조회의 경우에는 index 로 조회를 한다면 findById() 를 활용하여 조회를 하고, 삭제를 할 때는 deleteById() 를 활용하여 index 로 삭제를 할 것이다.

등록 : POST /members/1
조회 : GET /members/1
수정 : PUT /members/1
삭제 : DELETE /members/1
```

- Spring에서 의존성 주입을 지원하는 이유와 의존성 주입 방법에는 어떠한 것들이 있고, 가장 좋은 방법은 무엇인지, 왜 그것이 가장 좋은지 설명해주세요
```
클래스 내부에서 객체 간의 관계를 직접 설정을 하게 되면 프로그램 규모가 커지고 복잡해졌을 때 감당하기가 힘들어진다. 따라서 Spring Container 를 이용하여 객체를 생성하고 주입하는 방식인 의존성 주입 방식을 지원한 것이다.
외부에서 생성된 객체를 인터페이스를 통해 넘겨 받으면 결합도를 낮춰 확장성을 향상시키고, 런타임시에 의존관계가 결정되기 때문에 유연한 구조를 가진다. 그리고 재사용성을 높여주고, 종속성이 감소하여 변경에 민감하지도 않다.

의존성 주입에는 3가지 방법이 있다. 이는 생성자 주입, 필드 주입(Autowired), 수정자(Setter) 주입이 있는데 여기서 생성자 주입을 권장한다. 그 이유는 객체 생성자는 객체 생성시 1회만 호출되기 때문에 객체 불변성을 확보할 수 있고, 테스트에도 용이하다. 또한 생성자 주입은 다른 방법과 다르게 컴파일 시점에서 문제가 생길 경우 에러가 발생하는데 순환참조가 생길 경우 오류를 발생시키기 때문에 문제를 해결할 수 있도록 도와줘 생성자 주입 방식을 권장한다.
```

- JPA N + 1 문제가 발생하는 이유와 이를 해결하는 방법을 설명해주세요
```
JPA 에서 연관관계를 설정할 때 즉시 로딩을 할 경우, 첫 번째로 조회하는 쿼리외에 n 만큼의 연관관계의 조회 쿼리가 추가로 발생하는 현상을 말한다.
이를 해결하기 위한 방법으로는 Fetch Join, 엔티티 그래프 등의 방법이 있다. 그 중에서 fetch join 를 위주로 사용하니 이것만 설명읋 하려고 한다.

1. Fetch Join
JPQL 을 사용해서 처음부터 연관된 데이터까지 같이 가져오게 하는 방법이다. 위 문제가 발생하는 이유는 한 쪽 테이블만 조회하고 연결된 다른 테이블은 따로 조회하기 때문에 발생하는 문제이다. 그래서 두 테이블을 join 해서 한번에 모든 테이블을 가져올 수 있다면 문제가 발생하지 않을 것이다. join fetch 엔티티.연관관계_엔티티 구문을 만들어서 @Query 어노테이션으로 sql 문을 실행해주면 된다.
```

- Junit4와 Junit5의 차이점에 대해 설명해주세요
```
Junit 은 자바 유닛 테스트 프레임워크인데 Juni4 는 vintage-engine 을, Junit5 는 jupiter-engine 을 사용한다는 차이점이 있다. 그리고 Junit5 는 3개의 서브 프로젝트로 구성되어 있는데 각각은 Junit Platform, Junit Jupiter, Junit Vintage 이다.
Junit Platform 은 테스트를 실행하기 위한 기반이 되는 모듈이며, Junit Jupiter 는 테스트를 기수하기 위한 확장 모델이 담긴 모듈이다. Junit Vintage 는 테스트 엔진이다.
```

- JPA를 사용하는 이유에 대해 설명해주세요
```
JPA 는 ORM 즉 객체와 관계형 데이터베이스의 연결을 해주는 ORM 의 한 종류이다. 그렇기 때문에 SQL 중심 개발에서 객체 중심 개발이 가능하게 만들고, 객체와 RDB 간의 패러다임 불일치를 해결해준다.

//JPA, ORM 내용은 추후에 책을 읽고 더 정리하기!!
```

- 서블릿에 대해 설명해주세요
```
'최범균님의 JSP 2.3 웹 프로그래밍 기초부터 중급까지' 내용을 참고

서블릿은 클라이언트 요청을 처리하고 결과를 반환하는 Servlet 클래스 구현 규칙을 지킨 자바 웹 프로그래밍 기술이다.

서블릿은 JSP 표준이 나오기 전에 만들어진 표준으로 자바로 웹 어플리케이션을 개발할 수 있도록 하기 위해 만들어졌다. 서블릿을 이용하면 자바 클래스를 이용해서 웹 어플리케이션을 개발하게 된다.

서블릿을 구현하려면 HttpServlet 클래스를 상속 받은 클래스를 작성해야 하고 상속 받아야 서블릿으로 동작한다. 상속 받았다면 처리하고자 하는 HTTP 방식에 따라 알맞은 메소드를 재정의해서 구현해야 한다.
그 다음으로는 @WebServlet 어노테이션을 사용하여 서블릿을 등록한다.

서블릿 컨테이너는 처음 서블릿을 실행할 때 서블릿 객체를 생성한다. 최초 요청할 때 서블릿 객체를 생성하고, 이후 요청이 오면 앞서 생성한 서블릿 객체를 그대로 사용한다.
서블릿 객체를 생성할 때 init() 메소드를 호출하고 이를 호출하는 과정을 서블릿 로딩 과정이라고 한다.
보통 초기화 작업은 상대적으로 시간이 오래 걸리기 때문에, 처음 서블릿을 사용하는 시점보다는 웹 컨테이너를 처음 구동하는 시점에 초기화를 진행하는 것이 좋다.
```

- Spring의 DI, DL, IoC, AOP에 대해 설명해주세요
- Aop는 무엇이며 언제 사용할 수 있을까요?
- Spring WebFlux에 대해 설명해주세요
- 동기 방식과 비동기 방식의 차이에 대해 예를 들어 설명해주세요